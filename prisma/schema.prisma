// Enhanced Prisma schema - consolidating existing Sequelize models
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Minimal User model - wallet-based preferences only
// Social profiles (username, avatar, bio) fetched from Farcaster at runtime
model User {
  id            String   @id @default(cuid())
  walletAddress String   @unique // Primary identifier
  
  // Game generation preferences (user-specific settings)
  preferredModel String  @default("gpt-4o-mini")
  private        Boolean @default(false) // Hide games from public discovery
  
  // Relations
  games    Game[]
  chats    Chat[]
  sessions Session[]
  orders   Order[]
  payments Payment[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("users")
}

model Game {
  id          String @id @default(cuid())
  title       String
  slug        String @unique
  description String @db.Text
  tagline     String @db.Text
  genre       String
  subgenre    String

  // Game mode: "story" (default) or "wordle" (article-derived word puzzle)
  mode        String @default("story")

  // Visual customization
  primaryColor String?

  // AI generation metadata (consolidated)
  promptName       String  @default("GenerateGame-v2")
  promptText       String? @db.Text
  promptModel      String  @default("gpt-4o-mini")

  // Image generation
  imageUrl         String?  // Generated image URL (Venice AI)
  imagePromptModel String? 
  imagePromptName  String?
  imagePromptText  String? @db.Text
  imageData        Bytes?

  // Music generation  
  musicPromptText      String?
  musicPromptSeedImage String?

  // Mini App specific fields
  articleUrl         String?  // Original article URL (Paragraph)
  articleContext     String?  @db.Text  // Article summary used for game start narrative continuity
  writerCoinId       String?  // Which writer coin was used (e.g., "avc")
  difficulty         String?  // Game difficulty: "easy" or "hard"

  // Wordle-specific metadata (for article-derived word puzzles)
  wordleAnswer       String?
  
  // Source material attribution (preserves original author for Story Protocol & NFT metadata)
  authorParagraphUsername String?  // Original author's Paragraph username (e.g., "fred" from Fred Wilson)
  authorWallet            String?  // Original author's wallet address
  publicationName         String?  // Original publication name
  publicationSummary      String?  // Original publication summary
  subscriberCount         Int?     // Original publication subscriber count
  articlePublishedAt      DateTime?  // Original article publication date
  
  // Creator attribution (user who generated the game)
  creatorWallet           String?  // Game creator's wallet address

  // NFT minting fields
  nftTokenId       String?  // ERC-721 token ID
  nftTransactionHash String?  // Transaction hash for mint
  nftMintedAt      DateTime?  // When NFT was minted

  // Payment tracking
  paymentId        String?
  payment          Payment?  @relation(fields: [paymentId], references: [id])

  // Access control
  private Boolean @default(false)

  // Relations
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  chats Chat[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("games")
}

model Session {
  id        String   @id @default(cuid())
  sessionId String   @unique
  
  // Relations
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  chats Chat[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("sessions")
}

model Chat {
  id        String   @id @default(cuid())
  parentId  String?
  role      ChatRole
  content   String   @db.Text
  model     String
  
  // Relations
  sessionId String
  session   Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  gameId String
  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Self-referential for conversation threading
  parent   Chat?  @relation("ChatThread", fields: [parentId], references: [id])
  children Chat[] @relation("ChatThread")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("chats")
}

enum ChatRole {
  user
  assistant
  system
}

model Article {
  id          String    @id @default(cuid())
  title       String
  slug        String    @unique
  description String?   @db.Text
  content     String    @db.Text
  author      String?
  publishedAt DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("articles")
}

model Order {
  id           String      @id @default(cuid())
  stripeId     String?     @unique
  amount       Int         // in cents
  currency     String      @default("usd")
  status       OrderStatus @default(pending)
  
  // Relations
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("orders")
}

enum OrderStatus {
  pending
  completed
  failed
  refunded
}

// Payment tracking for writer coin transactions
model Payment {
  id               String   @id @default(cuid())
  transactionHash  String   @unique  // Blockchain tx hash
  action           String   // 'generate-game' or 'mint-nft'
  amount           BigInt   // Amount in token smallest unit
  status           String   @default("pending")  // 'pending' | 'verified' | 'failed'
  
  // Relations
  userId           String?
  user             User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  writerCoinId     String   // Which coin was used (e.g., "avc")
  
  // Game tracking
  games            Game[]
  
  createdAt        DateTime @default(now())
  verifiedAt       DateTime?
  
  @@map("payments")
}

// New models for WritArcade features

model ContentSource {
  id              String      @id @default(cuid())
  url             String      @unique
  type            ContentType
  title           String?
  author          String?
  
  // Newsletter/blog metadata
  rssUrl          String?
  webhookUrl      String?
  memecoinContract String?    // Base contract address
  tokenSymbol     String?
  tokenDecimals   Int?        @default(18)
  
  // Revenue sharing
  royaltyPercentage Int       @default(10) // percentage to creator
  pricePerGame      Int       @default(100) // tokens required
  
  // Scraping config
  autoScrapeFreq    String?   @default("daily")
  lastScrapedAt     DateTime?
  
  // Relations
  articles ProcessedArticle[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("content_sources")
}

enum ContentType {
  newsletter
  blog
  article
  unknown
}

model ProcessedArticle {
  id              String @id @default(cuid())
  originalUrl     String
  title           String?
  author          String?
  content         String @db.Text
  wordCount       Int
  estimatedReadTime Int // in minutes
  publishedAt     DateTime?
  
  // Relations
  sourceId String
  source   ContentSource @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  
  // Generated games from this article
  games GameFromArticle[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([sourceId, originalUrl])
  @@map("processed_articles")
}

model GameFromArticle {
  id String @id @default(cuid())
  
  // Relations
  gameId    String
  // Note: We'll handle game relation through application logic for now
  
  articleId String
  article   ProcessedArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)
  
  // User who generated this interpretation
  userId String
  
  // Generation metadata
  generationPrompt String @db.Text
  tokensSpent      Int
  memecoinUsed     String // token symbol
  
  createdAt DateTime @default(now())
  
  @@map("games_from_articles")
}

// Asset Marketplace Models (Phase 6)
model Asset {
  id          String   @id @default(cuid())
  title       String
  description String   @db.Text
  type        String   // 'character' | 'mechanic' | 'plot' | 'world' | 'dialog'
  content     String   @db.Text
  genre       String
  tags        String[] @default([])
  
  // Attribution
  articleUrl  String?
  creatorId   String?
  
  // Relations
  games                GameFromAsset[]
  revenues             AssetRevenue[]
  storyRegistration    AssetStoryRegistration?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("assets")
}

model GameFromAsset {
  id String @id @default(cuid())
  
  // Relations
  gameId  String
  
  assetId String
  asset   Asset @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  // User who built game from assets
  userId  String
  
  // Composition metadata
  compositionPrompt String @db.Text
  tokensSpent       Int
  
  createdAt DateTime @default(now())
  
  @@unique([gameId, assetId])
  @@map("games_from_assets")
}

model AssetRevenue {
  id String @id @default(cuid())
  
  // Relations
  assetId  String
  asset    Asset @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  gameId   String // Game that used this asset (not a foreign key - may be external)
  
  // Revenue tracking
  creatorId       String // Asset creator's wallet
  amount          BigInt // Revenue from this asset usage
  status          String @default("pending") // 'pending' | 'claimed' | 'distributed'
  
  createdAt DateTime @default(now())
  claimedAt DateTime?
  
  @@unique([assetId, gameId])
  @@map("asset_revenues")
}

// Story Protocol Asset Registration (Sprint 4)
model AssetStoryRegistration {
  id String @id @default(cuid())
  
  // Relations
  assetId String @unique
  asset   Asset  @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  // Story Protocol data
  storyIpId       String @unique // IP Asset ID on Story Protocol
  transactionHash String // Registration transaction hash
  blockNumber     Int    // Block where registration was mined
  metadataUri     String // IPFS URI for asset metadata
  
  // License configuration
  licenseTerms Json? // { commercialUse, commercialAttribution, derivatives, derivativeRoyalty }
  
  // Status tracking
  status        String @default("pending") // 'pending' | 'registered' | 'active'
  registeredAt  DateTime @default(now())
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("asset_story_registrations")
}